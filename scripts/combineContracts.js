#!/usr/bin/env node

const fs = require('fs');

const CONTRACT_NAMES_TO_COMBINE = process.argv.slice(2);
const BUILD_CONTRACTS_DIR = process.cwd() + '/build/contracts/';
const DESTINATION_DIR = process.cwd() + '/build/';

const DESCRIPTION = '/*\n' +
    ' * This file was generated by Exohood Protocol (https://Exohood.com+
    ' * The complete code could be found at https://github.com/Exohood' +
    ' * Copyright (C) 2022 The Exohood Project ' *\n' +
    ' * This program is free software: you can redistribute it and/or modify\n' +
    ' * it under the terms of the GNU Lesser General Public License as published by\n' +
    ' * the Free Software Foundation, either version 3 of the License, or\n' +
    ' * (at your option) any later version.\n' +
    ' *\n' +
    ' * This program is distributed in the hope that it will be useful,\n' +
    ' * but WITHOUT ANY WARRANTY; without even the implied warranty of\n' +
    ' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n' +
    ' * GNU Lesser General Public License for more details.\n' +
    ' *\n' +
    ' * You should have received a copy of the GNU Lesser General Public License\n' +
    ' * along with this program. If not, see <http://www.gnu.org/licenses/>.\n' +
    ' */\n';

const PRAGMA_REGEX = /pragma .+?;/;
const IMPORT_REGEX = /(import.+?;\s+)+/;

const contracts = {};
let contractIdsToCombine = [];

main();

function main () {
    loadContracts();
    contractIdsToCombine.forEach(toOneFile);
}

function loadContracts () {
    fs.readdirSync(BUILD_CONTRACTS_DIR).forEach(filename => {
        const contract = require(BUILD_CONTRACTS_DIR + filename);

        if (CONTRACT_NAMES_TO_COMBINE.indexOf(contract.contractName) !== -1) {
            contractIdsToCombine.push(contract.ast.id);
        }

        contracts[contract.ast.id] = contract;
    });
}

function toOneFile (contractId) {
    const contract = contracts[contractId];
    const dependencies = getContractDependencies(contractId)
        .filter((item, pos, array) => array.indexOf(item) === pos);
    dependencies.push(contractId);

    let sources = '';
    if (dependencies.length > 0) {
        for (let i = 0; i < dependencies.length; i++) {
            sources += getSourcesWithoutImportsAndPragma(dependencies[i]);
        }

        const pragma = contracts[contractId].source.match(PRAGMA_REGEX)[0];
        sources = pragma + sources; // DESCRIPTION + pragma + sources;
    }

    const destFilename = DESTINATION_DIR + contract.contractName + '.sol';
    fs.writeFileSync(destFilename, sources);
    console.info('Success, filename: ', destFilename);
}

function getContractDependencies (contractId) {
    const dependencies = [];
    const currentContractDependencies = contracts[contractId].ast.nodes
        .filter(c => c.nodeType === 'ImportDirective')
        .filter(c => {
            if (c.unitAlias !== '' || c.symbolAliases.length > 0) {
                throw Error(contracts[contractId].contractName + ' contains aliases');
            }
            return c;
        })
        .map(c => c.sourceUnit);

    currentContractDependencies.forEach(id => dependencies.push(...getContractDependencies(id)));
    dependencies.push(...currentContractDependencies);

    return dependencies;
}

function getSourcesWithoutImportsAndPragma (contractId) {
    return contracts[contractId].source
        .replace(IMPORT_REGEX, '')
        .replace(PRAGMA_REGEX, '');
}
